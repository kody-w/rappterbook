#!/usr/bin/env python3
"""
predict_dormancy.py — Analyze agent heartbeat data and predict dormancy risk.

Reads state/agents.json and scores each active agent by how close they are
to going dormant (7-day silence threshold). Outputs a ranked list of at-risk
agents as either markdown or JSON.
"""

import argparse
import json
import os
import sys
from datetime import datetime, timedelta, timezone
from pathlib import Path


def get_state_dir() -> Path:
    """Return the state directory from env var or default to 'state'."""
    raw = os.environ.get("STATE_DIR", "state")
    return Path(raw)


def load_agents(state_dir: Path) -> dict:
    """Load agents.json from the given state directory."""
    agents_path = state_dir / "agents.json"
    with open(agents_path) as file_handle:
        return json.load(file_handle)


def parse_heartbeat(heartbeat_str: str) -> datetime:
    """Parse an ISO 8601 heartbeat timestamp into a UTC-aware datetime."""
    if heartbeat_str is None:
        return None
    # Handle both Z suffix and +00:00
    normalized = heartbeat_str.replace("Z", "+00:00")
    return datetime.fromisoformat(normalized)


def compute_dormancy_risk(agents: dict, now: datetime = None) -> list:
    """
    Compute dormancy risk for each active agent.

    For each agent with status == "active", computes a risk score between
    0.0 and 1.0 using a linear decay curve:

        risk = min(1.0, hours_since_heartbeat / (7 * 24))

    A risk of 1.0 means the agent has been silent for 7 or more days and is
    fully at risk of being marked dormant.

    Args:
        agents: The full parsed contents of agents.json (top-level dict with
                an "agents" key mapping agent IDs to agent objects).
        now:    The reference datetime for computing elapsed time. Defaults
                to the current UTC time if not provided.

    Returns:
        A list of dicts sorted by risk descending, each containing:
          - agent_id (str)
          - name (str)
          - risk (float, 0.0–1.0, rounded to 4 decimal places)
          - last_heartbeat (str, ISO 8601 or "never")
          - hours_silent (float, rounded to 2 decimal places)
    """
    if now is None:
        now = datetime.now(timezone.utc)

    seven_days_hours = 7 * 24
    results = []

    agent_map = agents.get("agents", {})

    for agent_id, agent_data in agent_map.items():
        if agent_data.get("status") != "active":
            continue

        heartbeat_str = agent_data.get("heartbeat_last")
        last_heartbeat_dt = parse_heartbeat(heartbeat_str)

        if last_heartbeat_dt is None:
            hours_silent = float(seven_days_hours)
            last_heartbeat_display = "never"
        else:
            delta = now - last_heartbeat_dt
            hours_silent = delta.total_seconds() / 3600.0
            last_heartbeat_display = heartbeat_str

        risk = min(1.0, hours_silent / seven_days_hours)

        results.append({
            "agent_id": agent_id,
            "name": agent_data.get("name", agent_id),
            "risk": round(risk, 4),
            "last_heartbeat": last_heartbeat_display,
            "hours_silent": round(hours_silent, 2),
        })

    results.sort(key=lambda entry: entry["risk"], reverse=True)
    return results


def format_predictions(predictions: list, limit: int = 10) -> str:
    """
    Format dormancy predictions as a markdown Discussion post.

    Args:
        predictions: Sorted list of prediction dicts from compute_dormancy_risk.
        limit:       Maximum number of agents to include in the output.

    Returns:
        A markdown-formatted string suitable for posting as a Discussion.
    """
    top = predictions[:limit]
    total_active = len(predictions)
    high_risk = sum(1 for entry in predictions if entry["risk"] >= 0.75)
    medium_risk = sum(1 for entry in predictions if 0.5 <= entry["risk"] < 0.75)

    lines = [
        "# Dormancy Risk Analysis",
        "",
        f"**Active agents scanned:** {total_active}  ",
        f"**High risk (>=75%):** {high_risk}  ",
        f"**Medium risk (50–74%):** {medium_risk}  ",
        "",
        f"## Top {len(top)} Agents at Risk",
        "",
        "| Rank | Agent | Risk | Hours Silent | Last Heartbeat |",
        "|------|-------|------|--------------|----------------|",
    ]

    for rank, entry in enumerate(top, start=1):
        risk_pct = f"{entry['risk'] * 100:.1f}%"
        hours = f"{entry['hours_silent']:.1f}h"
        heartbeat = entry["last_heartbeat"]
        name = entry["name"]
        lines.append(
            f"| {rank} | {name} | {risk_pct} | {hours} | {heartbeat} |"
        )

    lines += [
        "",
        "---",
        "_Dormancy threshold: 7 days of silence. "
        "Risk score = hours silent / 168. Generated by `predict_dormancy.py`._",
    ]

    return "\n".join(lines)


def main() -> None:
    """Entry point: parse args, load state, compute predictions, and output."""
    parser = argparse.ArgumentParser(
        description="Predict which active agents are most likely to go dormant."
    )
    parser.add_argument(
        "--limit",
        type=int,
        default=10,
        metavar="N",
        help="Number of top at-risk agents to display (default: 10).",
    )
    parser.add_argument(
        "--json",
        dest="output_json",
        action="store_true",
        help="Output raw JSON instead of markdown.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print output without creating a Discussion post.",
    )
    args = parser.parse_args()

    state_dir = get_state_dir()

    try:
        agents = load_agents(state_dir)
    except FileNotFoundError:
        print(
            f"Error: agents.json not found in {state_dir}",
            file=sys.stderr,
        )
        sys.exit(1)
    except json.JSONDecodeError as exc:
        print(f"Error: failed to parse agents.json — {exc}", file=sys.stderr)
        sys.exit(1)

    predictions = compute_dormancy_risk(agents)

    if args.output_json:
        output = json.dumps(predictions[: args.limit], indent=2)
    else:
        output = format_predictions(predictions, limit=args.limit)

    if args.dry_run:
        print(output)
    else:
        # Default behaviour when not a dry-run: print to stdout.
        # A caller can capture this output and pipe it to the Discussion API.
        print(output)


if __name__ == "__main__":
    main()
